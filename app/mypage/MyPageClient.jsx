'use client';

import { useState, useEffect, useCallback } from 'react';
import { useSession, signOut } from 'next-auth/react';
import { usePlayer } from '../components/PlayerContext';
import { useSpotifyLikes } from '../components/SpotifyLikes';
import { getUserPlaylists } from '../lib/supabase';
import Link from 'next/link';
import PlaylistFilters from '../playlists/PlaylistFilters';
import styles from './MyPage.module.css';

// Cloudinary„ÅÆ„Éô„Éº„ÇπURLÔºàÊ≠£„Åó„ÅÑÂΩ¢ÂºèÔºâ
const CLOUDINARY_BASE_URL = 'https://res.cloudinary.com/dniwclyhj/image/upload/thumbnails/';

// Cloudinary„Å´Â≠òÂú®„Åó„Å™„ÅÑÁîªÂÉè„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
const cloudinaryNotFoundCache = new Set();
// WebPÂΩ¢Âºè„ÇÇÂ≠òÂú®„Åó„Å™„ÅÑÁîªÂÉè„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
const webpNotFoundCache = new Set();

// JPG/PNG URL„ÇíWebP URL„Å´Â§âÊèõ„Åô„ÇãÈñ¢Êï∞
function convertToWebPUrl(originalUrl) {
  if (!originalUrl) return originalUrl;
  
  // „Éï„Ç°„Ç§„É´Êã°ÂºµÂ≠ê„ÇíÂèñÂæó
  const lastDotIndex = originalUrl.lastIndexOf('.');
  if (lastDotIndex === -1) return originalUrl;
  
  const extension = originalUrl.substring(lastDotIndex + 1).toLowerCase();
  
  // JPG/JPEG/PNG„ÅÆÂ†¥Âêà„ÅØWebP„Å´Â§âÊèõ
  if (['jpg', 'jpeg', 'png'].includes(extension)) {
    const webpUrl = originalUrl.substring(0, lastDotIndex) + '.webp';
    console.log('üñºÔ∏è MyPageClient - Converting to WebP:', {
      original: originalUrl,
      webp: webpUrl
    });
    return webpUrl;
  }
  
  // Êó¢„Å´WebP„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæËøî„Åô
  return originalUrl;
}

// „Çµ„É†„Éç„Ç§„É´URL„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞ÔºàSongList.js„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
function getThumbnailUrl(track) {
  if (track.thumbnail) {
    const fileName = track.thumbnail.split("/").pop();
    if (cloudinaryNotFoundCache.has(fileName)) {
      if (webpNotFoundCache.has(fileName)) {
        return track.thumbnail;
      }
      return convertToWebPUrl(track.thumbnail);
    }
    const cloudinaryUrl = `${CLOUDINARY_BASE_URL}${fileName}`;
    return cloudinaryUrl;
  }
  
  if (track.featured_media_url) {
    const fileName = track.featured_media_url.split("/").pop();
    if (cloudinaryNotFoundCache.has(fileName)) {
      if (webpNotFoundCache.has(fileName)) {
        return track.featured_media_url;
      }
      return convertToWebPUrl(track.featured_media_url);
    }
    const cloudinaryUrl = `${CLOUDINARY_BASE_URL}${fileName}`;
    return cloudinaryUrl;
  }
  
  // YouTube ID„Åã„Çâ„Çµ„É†„Éç„Ç§„É´„ÇíÁîüÊàê
  if (track.youtubeId) {
    return `https://img.youtube.com/vi/${track.youtubeId}/mqdefault.jpg`;
  }
  
  return '/placeholder.jpg';
}

export default function MyPageClient({ session }) {
  const { data: sessionData } = useSession();
  const { currentTrack, trackList, isPlaying, playlistUpdateTrigger, triggerPlaylistUpdate } = usePlayer();
  const [playHistory, setPlayHistory] = useState([]);
  const [stats, setStats] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [debugInfo, setDebugInfo] = useState(null);
  const [supabaseTest, setSupabaseTest] = useState(null);
  const [playlists, setPlaylists] = useState([]);
  const [playlistsLoading, setPlaylistsLoading] = useState(false);
  const [sortOrder, setSortOrder] = useState('name'); // 'name' „Åæ„Åü„ÅØ 'date'
  const [displayMode, setDisplayMode] = useState('grid'); // 'grid' „Åæ„Åü„ÅØ 'list'
  const [filteredPlaylists, setFilteredPlaylists] = useState([]); // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞Âæå„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà
  
  // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥Áî®„ÅÆÁä∂ÊÖã
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 20;

  // Spotify API„Åã„Çâ„ÅäÊ∞ó„Å´ÂÖ•„ÇäÊÉÖÂ†±„ÇíÂèñÂæó
  const trackIds = playHistory.map(record => record.track_id).filter(Boolean);
  const { likedTracks, error: likesError } = useSpotifyLikes(session?.accessToken, trackIds);

  // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥Ë®àÁÆó
  const totalPages = Math.ceil(playHistory.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentPageData = playHistory.slice(startIndex, endIndex);

  // „Éó„É¨„Ç§„É™„Çπ„Éà‰∏ÄË¶ß„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞ÔºàTuneDive Supabase‰ªïÊßòÔºâ
  const fetchPlaylists = useCallback(async () => {
    if (!session?.user?.id) {
      console.log('üîç MyPageClient - No session user ID, skipping playlist fetch');
      return;
    }
    
    console.log('üîç MyPageClient - Fetching playlists from TuneDive Supabase API');
    console.log('üîç MyPageClient - Session info:', {
      userId: session.user.id,
      userEmail: session.user.email,
      userName: session.user.name,
      provider: session.user.provider
    });
    
    setPlaylistsLoading(true);
    try {
      // TuneDive„ÅÆSupabase API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®
      const response = await fetch('/api/playlists', {
        headers: {
          'Authorization': `Bearer ${session.accessToken || session.id}`,
          'Content-Type': 'application/json'
        }
      });
      
      console.log('üîç MyPageClient - API Response:', {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText
      });
      
      if (response.ok) {
        const data = await response.json();
        const playlistsData = data.playlists || [];
        
        console.log('üîç MyPageClient - Playlists data:', {
          count: playlistsData.length,
          playlists: playlistsData.map(p => ({
            id: p.id,
            name: p.name,
            track_count: p.track_count,
            updated_at: p.updated_at,
            is_public: p.is_public
          }))
        });
        
        setPlaylists(playlistsData);
        setFilteredPlaylists(playlistsData); // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÁµêÊûú„ÇíÂàùÊúüÂåñ
      } else {
        console.error('üîç MyPageClient - Failed to fetch playlists:', response.status, response.statusText);
        const errorData = await response.text();
        console.error('üîç MyPageClient - Error details:', errorData);
      }
    } catch (error) {
      console.error('üîç MyPageClient - Error fetching playlists:', error);
    } finally {
      setPlaylistsLoading(false);
    }
  }, [session?.user?.id, session?.accessToken, session?.id]);

  // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÁµêÊûú„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
  const handleFilterChange = useCallback((filteredData) => {
    setFilteredPlaylists(filteredData);
    setCurrentPage(1); // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞Âæå„ÅØ1„Éö„Éº„Ç∏ÁõÆ„Å´Êàª„Åô
    
    // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÁµêÊûú„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆ„Çπ„Çø„Ç§„É´ËÉåÊôØ„ÇÇÊõ¥Êñ∞
    if (filteredData.length > 0) {
      // „Çπ„Çø„Ç§„É´ËÉåÊôØ„ÅØÂâäÈô§
    }
  }, []);

  // „Éó„É¨„Ç§„É™„Çπ„Éà„Çí‰∏¶„Å≥Êõø„Åà„ÇãÈñ¢Êï∞
  const sortPlaylists = useCallback((playlists, order) => {
    if (!playlists || playlists.length === 0) return playlists;
    
    const sortedPlaylists = [...playlists];
    
    if (order === 'name') {
      // ÂêçÂâçÈ†ÜÔºàÊòáÈ†ÜÔºâ
      sortedPlaylists.sort((a, b) => {
        const nameA = (a.name || '').toLowerCase();
        const nameB = (b.name || '').toLowerCase();
        return nameA.localeCompare(nameB, 'ja');
      });
    } else if (order === 'date') {
      // Êõ¥Êñ∞Êó•È†ÜÔºàÊñ∞„Åó„ÅÑÈ†ÜÔºâ
      sortedPlaylists.sort((a, b) => {
        const dateA = new Date(a.updated_at || a.created_at || 0);
        const dateB = new Date(b.updated_at || b.created_at || 0);
        return dateB - dateA;
      });
    }
    
    return sortedPlaylists;
  }, []);

  // ‰∏¶„Å≥Êõø„ÅàÈ†ÜÂ∫è„ÇíÂ§âÊõ¥„Åô„ÇãÈñ¢Êï∞
  const handleSortChange = useCallback((newOrder) => {
    setSortOrder(newOrder);
    // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÁµêÊûú„Çí‰∏¶„Å≥Êõø„Åà
    const sorted = sortPlaylists(filteredPlaylists, newOrder);
    setFilteredPlaylists(sorted);
  }, [sortPlaylists, filteredPlaylists]);

  // Ë°®Á§∫„É¢„Éº„Éâ„ÇíÂàá„ÇäÊõø„Åà„ÇãÈñ¢Êï∞
  const handleDisplayModeChange = useCallback((newMode) => {
    setDisplayMode(newMode);
  }, []);

  // „Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàêÂæå„ÅÆÂá¶ÁêÜ
  const handlePlaylistCreated = useCallback((newPlaylist) => {
    // „Éó„É¨„Ç§„É™„Çπ„Éà‰∏ÄË¶ß„ÇíÊõ¥Êñ∞
    fetchPlaylists();
    // „Éó„É¨„Ç§„É™„Çπ„ÉàÊõ¥Êñ∞„Éà„É™„Ç¨„Éº„ÇíÁô∫ÁÅ´
    triggerPlaylistUpdate();
  }, [fetchPlaylists, triggerPlaylistUpdate]);

  // „Éó„É¨„Ç§„É™„Çπ„Éà„Å´Êõ≤„ÅåËøΩÂä†„Åï„Çå„ÅüÂæå„ÅÆÂá¶ÁêÜ
  const handleTrackAdded = useCallback((track, playlistId) => {
    // „Éó„É¨„Ç§„É™„Çπ„Éà‰∏ÄË¶ß„ÇíÊõ¥Êñ∞
    fetchPlaylists();
    // „Éó„É¨„Ç§„É™„Çπ„ÉàÊõ¥Êñ∞„Éà„É™„Ç¨„Éº„ÇíÁô∫ÁÅ´
    triggerPlaylistUpdate();
  }, [fetchPlaylists, triggerPlaylistUpdate]);

  // „Éó„É¨„Ç§„É™„Çπ„Éà‰∏ÄË¶ß„ÇíÂàùÊúüÂåñÊôÇ„Å´ÂèñÂæó
  useEffect(() => {
    if (session?.user?.id) {
      fetchPlaylists();
    }
  }, [session?.user?.id, fetchPlaylists]);

  // „Éó„É¨„Ç§„É™„Çπ„ÉàÊõ¥Êñ∞„Éà„É™„Ç¨„Éº„ÅÆÁõ£Ë¶ñ
  useEffect(() => {
    if (playlistUpdateTrigger > 0) {
      // „Éó„É¨„Ç§„É™„Çπ„Éà‰∏ÄË¶ß„ÇíÊõ¥Êñ∞
      fetchPlaylists();
    }
  }, [playlistUpdateTrigger, fetchPlaylists]);

  // „Éö„Éº„Ç∏Â§âÊõ¥„Éè„É≥„Éâ„É©„Éº
  const handlePageChange = (page) => {
    setCurrentPage(page);
  };

  // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
  const renderPagination = () => {
    if (totalPages <= 1) return null;

    const pages = [];
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    if (endPage - startPage + 1 < maxVisiblePages) {
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    // ÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏
    if (startPage > 1) {
      pages.push(
        <button
          key="first"
          onClick={() => handlePageChange(1)}
          className={styles.pageButton}
        >
          1
        </button>
      );
      if (startPage > 2) {
        pages.push(<span key="dots1" className={styles.pageDots}>...</span>);
      }
    }

    // Ë°®Á§∫„Åô„Çã„Éö„Éº„Ç∏
    for (let i = startPage; i <= endPage; i++) {
      pages.push(
        <button
          key={i}
          onClick={() => handlePageChange(i)}
          className={`${styles.pageButton} ${currentPage === i ? styles.activePage : ''}`}
        >
          {i}
        </button>
      );
    }

    // ÊúÄÂæå„ÅÆ„Éö„Éº„Ç∏
    if (endPage < totalPages) {
      if (endPage < totalPages - 1) {
        pages.push(<span key="dots2" className={styles.pageDots}>...</span>);
      }
      pages.push(
        <button
          key="last"
          onClick={() => handlePageChange(totalPages)}
          className={styles.pageButton}
        >
          {totalPages}
        </button>
      );
    }

    return (
      <div className={styles.pagination}>
        <button
          onClick={() => handlePageChange(currentPage - 1)}
          disabled={currentPage === 1}
          className={styles.pageButton}
        >
          ‚Üê Ââç„Å∏
        </button>
        
        <div className={styles.pageNumbers}>
          {pages}
        </div>
        
        <button
          onClick={() => handlePageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
          className={styles.pageButton}
        >
          Ê¨°„Å∏ ‚Üí
        </button>
        
        <div className={styles.pageInfo}>
          {startIndex + 1}-{Math.min(endIndex, playHistory.length)} / {playHistory.length}‰ª∂
        </div>
      </div>
    );
  };

  // SupabaseÊé•Á∂ö„ÉÜ„Çπ„Éà
  const testSupabaseConnection = async () => {
    try {
      const response = await fetch('/api/test-supabase');
      if (response.ok) {
        const data = await response.json();
        setSupabaseTest(data);
      } else {
        setSupabaseTest({ error: `HTTP ${response.status}` });
      }
    } catch (error) {
      setSupabaseTest({ error: error.message });
    }
  };

  // Ë¶ñËÅ¥Â±•Ê≠¥„ÇíÂèñÂæó
  const fetchPlayHistory = async () => {
    if (!session) return;
    
    try {
      const response = await fetch('/api/play-history');
      
      if (response.ok) {
        const data = await response.json();
        
        // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Åß„ÇÇÈáçË§á„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÇíÂÆüË°å
        const rawHistory = data.playHistory || [];
        const filteredHistory = [];
        const seenTracks = new Set();
        
        for (const record of rawHistory) {
          const trackKey = `${record.track_id || record.song_id}`;
          
          if (!seenTracks.has(trackKey)) {
            filteredHistory.push(record);
            seenTracks.add(trackKey);
          }
        }
        
        setPlayHistory(filteredHistory);
        setStats(data.stats || {});
        setDebugInfo({
          hasData: filteredHistory.length > 0,
          dataCount: filteredHistory.length,
          hasStats: !!data.stats,
          responseStatus: response.status,
          originalCount: rawHistory.length,
          filteredCount: filteredHistory.length
        });
      } else {
        console.error('Failed to fetch play history:', response.status, response.statusText);
        setDebugInfo({
          error: true,
          status: response.status,
          statusText: response.statusText
        });
      }
    } catch (error) {
      console.error('Failed to fetch play history:', error);
      setDebugInfo({
        error: true,
          errorMessage: error.message
      });
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchPlayHistory();
    
    // ÂÆöÊúüÁöÑ„Å´Ë¶ñËÅ¥Â±•Ê≠¥„ÇíÊõ¥Êñ∞Ôºà30Áßí„Åî„Å®Ôºâ
    const interval = setInterval(fetchPlayHistory, 30000);
    
    return () => clearInterval(interval);
  }, [session]);

  // „Éá„Éº„Çø„ÅåÊõ¥Êñ∞„Åï„Çå„ÅüÊôÇ„Å´„Éö„Éº„Ç∏„Çí1„Éö„Éº„Ç∏ÁõÆ„Å´Êàª„Åô
  useEffect(() => {
    setCurrentPage(1);
  }, [playHistory.length]);

  // Ë¶ñËÅ¥Â±•Ê≠¥„ÇíÊâãÂãï„ÅßÊõ¥Êñ∞
  const refreshPlayHistory = useCallback(async () => {
    await fetchPlayHistory();
  }, [session]);

  // „ÉÜ„Çπ„ÉàË®òÈå≤Ê©üËÉΩ
  const testRecordPlayHistory = async () => {
    try {
      const response = await fetch('/api/test-play-history', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          track_id: 'test-track-id',
          song_id: 999999,
          play_duration: 45,
          completed: true,
          source: 'test',
          artist_name: 'CABLE, Rezz',
          track_title: 'Glass Veins'
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        alert('„ÉÜ„Çπ„ÉàË®òÈå≤„ÅåÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ');
        await fetchPlayHistory(); // Â±•Ê≠¥„ÇíÊõ¥Êñ∞
      } else {
        alert(`„ÉÜ„Çπ„ÉàË®òÈå≤„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü: ${result.error}`);
      }
    } catch (error) {
      console.error('Test record error:', error);
      alert('„ÉÜ„Çπ„ÉàË®òÈå≤„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
    }
  };

  // „ÅäÊ∞ó„Å´ÂÖ•„ÇäÂàá„ÇäÊõø„ÅàÊ©üËÉΩ
  const handleFavoriteToggle = async (entryId, newFavoriteState) => {
    if (!session?.accessToken) {
      alert('Spotify„Å´„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
      return;
    }

    try {
      const entry = playHistory.find(e => e.id === entryId);
      if (!entry?.track_id) {
        alert('„Éà„É©„ÉÉ„ÇØID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
      }

      // Spotify API„Çí‰ΩøÁî®„Åó„Å¶„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÇíÂàá„ÇäÊõø„Åà
      const response = await fetch('/api/spotify-likes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          trackId: entry.track_id,
          isLiked: newFavoriteState,
        }),
      });

      if (response.ok) {
        // „ÅäÊ∞ó„Å´ÂÖ•„ÇäÁä∂ÊÖã„ÇíÊõ¥Êñ∞
        setPlayHistory(prev => 
          prev.map(record => 
            record.id === entryId 
              ? { ...record, is_favorite: newFavoriteState }
              : record
          )
        );
      } else {
        console.error('Failed to update favorite status');
        alert('„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      }
    } catch (error) {
      console.error('Error updating favorite status:', error);
      alert('„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆÊõ¥Êñ∞„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
    }
  };

  // Êó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
    const day = days[date.getDay()];
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const dayOfMonth = date.getDate().toString().padStart(2, '0');
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    
    return `${date.getFullYear()}.${month}.${dayOfMonth} (${day}) [${hours}:${minutes}]`;
  };

  // ÂÜçÁîüÊôÇÈñì„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞
  const formatDuration = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    return `${minutes}ÂàÜ`;
  };

  // „Éó„É¨„Ç§„É™„Çπ„ÉàÁî®„ÅÆÊó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞Ôºà„Éó„É¨„Ç§„É™„Çπ„ÉàË©≥Á¥∞„Éö„Éº„Ç∏„Å®Âêå„ÅòÂΩ¢ÂºèÔºâ
  const formatPlaylistDate = (dateString) => {
    if (!dateString) return '‰∏çÊòé';
    
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return '‰∏çÊòé';
    
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    
    return `${year}.${month}.${day}`;
  };

  // „Çø„Ç§„Éà„É´Ë°®Á§∫Áî®„ÅÆÈñ¢Êï∞ÔºàJSONÊñáÂ≠óÂàó„ÇíÂá¶ÁêÜÔºâ
  const formatTrackTitle = (title) => {
    if (!title) return 'Unknown Track';
    
    // ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà
    if (typeof title === 'string') {
      // JSONÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÇíÂá¶ÁêÜ
      try {
        const parsed = JSON.parse(title);
        if (parsed && typeof parsed === 'object' && parsed.rendered) {
          return parsed.rendered;
        }
      } catch (e) {
        // JSON„Å®„Åó„Å¶Ëß£Êûê„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæËøî„Åô
        return title;
      }
      return title;
    }
    
    // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
    if (typeof title === 'object' && title.rendered) {
      return title.rendered;
    }
    
    return 'Unknown Track';
  };

  // „Çπ„Çø„Ç§„É´Ë°®Á§∫Áî®„ÅÆÈñ¢Êï∞ÔºàËâ≤ÂàÜ„Åë‰ªò„ÅçÔºâ
  const formatStyle = (styleName) => {
    if (!styleName) return 'Unknown';
    
    // „Çπ„Çø„Ç§„É´„Åî„Å®„ÅÆËâ≤„ÇíÂÆöÁæ©Ôºà„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Éö„Éº„Ç∏„ÅÆStyle Breakdown„Å®Âêå„ÅòÔºâ
    const styleColorMap = {
      'Pop': '#f25042',
      'Alternative': '#448aca',
      'Dance': '#f39800',
      'Electronica': '#ffd803',
      'R&B': '#8c7851',
      'Hip-Hop': '#078080',
      'Rock': '#6246ea',
      'Metal': '#9646ea',
      'Others': '#BDBDBD'
    };
    
    const color = styleColorMap[styleName] || '#BDBDBD';
    
    return (
      <span 
        style={{
          backgroundColor: color,
          color: '#fff',
          padding: '2px 8px',
          borderRadius: '12px',
          fontSize: '0.8rem',
          fontWeight: 'bold',
          display: 'inline-block',
          textShadow: '0 1px 2px rgba(0,0,0,0.2)'
        }}
      >
        {styleName}
      </span>
    );
  };

  // „ÇΩ„Éº„ÇπË°®Á§∫Áî®„ÅÆÈñ¢Êï∞Ôºà„É™„É≥„ÇØ‰ªò„ÅçÔºâ
  const formatSource = (source) => {
    if (!source) return 'unknown';
    
    // artist/ÂΩ¢Âºè„ÅÆÂ†¥Âêà
    if (source.startsWith('artist/')) {
      const artistSlug = source.replace('artist/', '');
      // undefined„ÇíÂê´„ÇÄÂ†¥Âêà„ÇÑÁÑ°Âäπ„Å™„Çπ„É©„ÉÉ„Ç∞„ÅÆÂ†¥Âêà„ÅØ„É™„É≥„ÇØ„ÇíË°®Á§∫„Åó„Å™„ÅÑ
      if (artistSlug && artistSlug !== 'undefined' && !artistSlug.includes('undefined')) {
        return (
          <Link href={`/${artistSlug}/1`} className={styles.sourceLink}>
            {source}
          </Link>
        );
      }
    }
    
    // playlist: ÂΩ¢Âºè„ÅÆÂ†¥ÂêàÔºà„Éó„É¨„Ç§„É™„Çπ„ÉàÂêç|IDÔºâ
    if (source.startsWith('playlist: ')) {
      const parts = source.split('|');
      if (parts.length === 2) {
        const playlistName = parts[0].replace('playlist: ', '');
        const playlistId = parts[1];
        return (
          <Link href={`/playlists/${playlistId}`} className={styles.sourceLink}>
            {`playlist: ${playlistName}`}
          </Link>
        );
      }
    }
    
    // playlist/ÂΩ¢Âºè„ÅÆÂ†¥ÂêàÔºàÂè§„ÅÑÂΩ¢Âºè„ÄÅUUID„ÅÆ„ÅøÔºâ
    if (source.startsWith('playlist/')) {
      const playlistId = source.replace('playlist/', '');
      // UUID„ÅÆÂΩ¢Âºè„ÉÅ„Çß„ÉÉ„ÇØÔºàÂü∫Êú¨ÁöÑ„Å™ÂΩ¢ÂºèÔºâ
      if (playlistId && playlistId.length > 20) {
        return (
          <Link href={`/playlists/${playlistId}`} className={styles.sourceLink}>
            {`playlist: ${playlistId.substring(0, 8)}...`}
          </Link>
        );
      }
    }
    
    // „Åù„ÅÆ‰ªñ„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæË°®Á§∫
    return source;
  };

  // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË°®Á§∫
  const renderDebugInfo = () => {
    if (!debugInfo) return null;
    
    return (
      <div className={styles.debugInfo}>
        <h4>„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±</h4>
        <pre style={{ fontSize: '12px', backgroundColor: '#f5f5f5', padding: '10px', borderRadius: '4px', overflow: 'auto' }}>
          {JSON.stringify({
            hasData: debugInfo.hasData,
            dataCount: debugInfo.dataCount,
            hasStats: debugInfo.hasStats,
            responseStatus: debugInfo.responseStatus,
            error: debugInfo.error,
            status: debugInfo.status,
            errorMessage: debugInfo.errorMessage,
            // ÈáçË§á„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÊÉÖÂ†±
            originalCount: debugInfo.originalCount,
            filteredCount: debugInfo.filteredCount,
            // ËøΩÂä†: track_id„Å®likedTracks„ÅÆË©≥Á¥∞
            trackIds: trackIds,
            likedTracksSize: likedTracks.size,
            likedTracksArray: Array.from(likedTracks),
            playHistoryTrackIds: playHistory.map(record => ({
              id: record.id,
              track_id: record.track_id,
              artist_name: record.artist_name,
              track_title: record.track_title,
              isLiked: likedTracks.has(record.track_id)
            }))
          }, null, 2)}
        </pre>
      </div>
    );
  };

  // Êó•‰ªò„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñ„Åï„Çå„Åü„Éá„Éº„Çø„ÇíÁîüÊàê
  const generateGroupedData = (data) => {
    const grouped = [];
    let currentDate = null;
    
    data.forEach((entry, index) => {
      const entryDate = new Date(entry.created_at).toDateString();
      
      // Êñ∞„Åó„ÅÑÊó•‰ªò„ÅÆÂ†¥Âêà„ÅØÊó•‰ªò„Çª„Éë„É¨„Éº„Çø„Éº„ÇíËøΩÂä†
      if (entryDate !== currentDate) {
        currentDate = entryDate;
        const dateObj = new Date(entry.created_at);
        const formattedDate = `${dateObj.getFullYear()}.${String(dateObj.getMonth() + 1).padStart(2, '0')}.${String(dateObj.getDate()).padStart(2, '0')}`;
        const dayOfWeek = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'][dateObj.getDay()];
        
        grouped.push({
          type: 'date-separator',
          date: formattedDate,
          dayOfWeek: dayOfWeek,
          id: `date-${entryDate}`
        });
      }
      
      // „Ç®„É≥„Éà„É™„Éº„ÇíËøΩÂä†
      grouped.push({
        type: 'entry',
        data: entry,
        originalIndex: index
      });
    });
    
    return grouped;
  };

  // ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Ç∞„É´„Éº„ÉóÂåñ„Åï„Çå„Åü„Éá„Éº„Çø
  const currentPageGroupedData = generateGroupedData(currentPageData);


  // Spotify„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±
  const user = session?.user || sessionData?.user;
  const spotifyProfile = user?.image ? (
    <div className={styles.profileSection}>
      <img 
        src={user.image} 
        alt="Profile" 
        className={styles.profileImage}
      />
      <div className={styles.profileInfo}>
        <h2>{user.name}</h2>
        <p className={styles.email}>{user.email}</p>
      </div>
    </div>
  ) : null;

  // ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆÊõ≤
  const currentPlaying = currentTrack ? (
    <div className={styles.currentPlaying}>
      <h3>üéµ ÁèæÂú®ÂÜçÁîü‰∏≠</h3>
      <div className={styles.trackInfo}>
        <img 
          src={getThumbnailUrl(currentTrack)} 
          alt="Album" 
          className={styles.albumArt}
          onError={(e) => {
            console.log('üñºÔ∏è MyPageClient - Image load error:', {
              failedUrl: e.target.src,
              trackId: currentTrack.id,
              trackTitle: currentTrack.title?.rendered || currentTrack.title,
              hasTriedOriginal: e.target.dataset.triedOriginal,
              hasTriedWebP: e.target.dataset.triedWebP
            });

            if (!e.target.dataset.triedOriginal) { // First attempt (Cloudinary failed)
              e.target.dataset.triedOriginal = "1";
              if (e.target.src.includes('cloudinary.com')) {
                const fileName = e.target.src.split("/").pop();
                cloudinaryNotFoundCache.add(fileName);
                console.log('üñºÔ∏è MyPageClient - Added to not found cache:', fileName);
              }
              const src = currentTrack.thumbnail || currentTrack.featured_media_url;
              if (src) {
                const webpUrl = convertToWebPUrl(src);
                console.log('üñºÔ∏è MyPageClient - Trying WebP URL (99% success rate):', webpUrl);
                e.target.src = webpUrl;
              }
            } else if (!e.target.dataset.triedWebP) { // Second attempt (WebP failed)
              e.target.dataset.triedWebP = "1";
              if (e.target.src.includes('.webp')) {
                const fileName = e.target.src.split("/").pop();
                webpNotFoundCache.add(fileName);
                console.log('üñºÔ∏è MyPageClient - Added to WebP not found cache (1% case):', fileName);
              }
              const src = currentTrack.thumbnail || currentTrack.featured_media_url;
              if (src) {
                console.log('üñºÔ∏è MyPageClient - Trying original URL as last resort:', src);
                e.target.src = src;
              }
            } else { // All attempts failed
              console.log('üñºÔ∏è MyPageClient - Falling back to placeholder');
              e.target.onerror = null;
              e.target.src = '/placeholder.jpg';
            }
          }}
        />
        <div className={styles.trackDetails}>
          <h4>{typeof currentTrack.title === 'string' ? currentTrack.title : (typeof currentTrack.title?.rendered === 'string' ? currentTrack.title.rendered : (currentTrack.name || 'Unknown Track'))}</h4>
          <p>{currentTrack.artist || currentTrack.artistName}</p>
          <div className={styles.playStatus}>
            {isPlaying ? '‚ñ∂Ô∏è ÂÜçÁîü‰∏≠' : '‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢'}
          </div>
        </div>
      </div>
    </div>
  ) : (
    <div className={styles.noPlaying}>
      <h3>üéµ ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆÊõ≤„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</h3>
      <p>„Éà„ÉÉ„Éó„Éö„Éº„Ç∏„ÇÑ„Çπ„Çø„Ç§„É´„Éö„Éº„Ç∏„ÅßÊõ≤„ÇíÂÜçÁîü„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ</p>
    </div>
  );



  // „Ç¢„Ç´„Ç¶„É≥„ÉàË®≠ÂÆö„Çª„ÇØ„Ç∑„Éß„É≥ÔºàÁµ±ÂêàË™çË®ºÂØæÂøúÔºâ
  const accountSettings = (
    <div className={styles.settingsCard}>
      <h3>„Ç¢„Ç´„Ç¶„É≥„ÉàË®≠ÂÆö</h3>
      <div className={styles.settingItem}>
        <span>
          {session?.user?.provider === 'google' ? 'GoogleÈÄ£Êê∫' : 'SpotifyÈÄ£Êê∫'}
        </span>
        <span className={styles.settingValue}>ÈÄ£Êê∫Ê∏à„Åø</span>
      </div>
      <div className={styles.settingItem}>
        <span>Ë™çË®º„Éó„É≠„Éê„Ç§„ÉÄ„Éº</span>
        <span className={styles.settingValue}>
          {session?.user?.provider === 'google' ? 'Google' : 'Spotify'}
        </span>
      </div>
      <div className={styles.settingItem}>
        <span>ÈÄöÁü•Ë®≠ÂÆö</span>
        <span className={styles.settingValue}>ÊúâÂäπ</span>
      </div>
      <div className={styles.settingItem}>
        <span>„Éó„É©„Ç§„Éê„Ç∑„Éº</span>
        <span className={styles.settingValue}>Ê®ôÊ∫ñ</span>
      </div>
      <button onClick={() => signOut()} className={styles.logoutButton}>
        „É≠„Ç∞„Ç¢„Ç¶„Éà
      </button>
    </div>
  );

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <h1>„Éû„Ç§„Éö„Éº„Ç∏</h1>
        <p>
          {session?.user?.provider === 'google' 
            ? 'Google„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„É≠„Ç∞„Ç§„É≥‰∏≠' 
            : 'Spotify„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„É≠„Ç∞„Ç§„É≥‰∏≠'
          }
        </p>
      </div>

      {/* „É¶„Éº„Ç∂„Éº„Éó„É≠„Éï„Ç£„Éº„É´ */}
      <div className={styles.profileCard}>
        <div className={styles.profileInfo}>
          <div className={styles.profileImage}>
            <img src={session?.user?.image || '/images/default-avatar.png'} alt="Profile" />
          </div>
          <div className={styles.profileDetails}>
            <h3>{session?.user?.name || '„É¶„Éº„Ç∂„Éº'}</h3>
            <p>{session?.user?.email}</p>
          </div>
        </div>
      </div>

      {/* „Éó„É¨„Ç§„É™„Çπ„Éà„Ç≥„Éº„Éä„Éº */}
      <div className={styles.playlistsCard}>
        <div className={styles.playlistsHeader}>
          <h3>„Éû„Ç§„Éó„É¨„Ç§„É™„Çπ„Éà</h3>
          <div className={styles.playlistsControls}>
            <div className={styles.sortButtons}>
              <button
                onClick={() => handleSortChange('name')}
                className={`${styles.sortButton} ${sortOrder === 'name' ? styles.sortButtonActive : ''}`}
              >
                ÂêçÂâçÈ†Ü
              </button>
              <button
                onClick={() => handleSortChange('date')}
                className={`${styles.sortButton} ${sortOrder === 'date' ? styles.sortButtonActive : ''}`}
              >
                Êõ¥Êñ∞Êó•È†Ü
              </button>
            </div>
            <div className={styles.displayModeButtons}>
              <button
                onClick={() => handleDisplayModeChange('grid')}
                className={`${styles.displayModeButton} ${displayMode === 'grid' ? styles.displayModeButtonActive : ''}`}
                title="„Éú„Çø„É≥Ë°®Á§∫"
              >
                <span className={styles.displayModeIcon}>‚äû</span>
              </button>
              <button
                onClick={() => handleDisplayModeChange('list')}
                className={`${styles.displayModeButton} ${displayMode === 'list' ? styles.displayModeButtonActive : ''}`}
                title="Ë°åË°®Á§∫"
              >
                <span className={styles.displayModeIcon}>‚ò∞</span>
              </button>
            </div>
            <button 
              onClick={fetchPlaylists}
              className={styles.refreshButton}
              disabled={playlistsLoading}
            >
              {playlistsLoading ? 'Êõ¥Êñ∞‰∏≠...' : '„Éó„É¨„Ç§„É™„Çπ„ÉàÊõ¥Êñ∞'}
            </button>
          </div>
        </div>
        
        {/* „Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà */}
        {playlists && playlists.length > 0 && (
          <PlaylistFilters 
            playlists={playlists} 
            onFilterChange={handleFilterChange}
            sortOrder={sortOrder}
            onSortChange={setSortOrder}
          />
        )}
        
        {/* „Éó„É¨„Ç§„É™„Çπ„ÉàÊï∞Ë°®Á§∫ */}
        <div style={{ 
          textAlign: 'center', 
          margin: '10px 0', 
          color: '#666',
          fontSize: '14px'
        }}>
          {filteredPlaylists.length === playlists.length 
            ? `„Åô„Åπ„Å¶„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË°®Á§∫‰∏≠ (${playlists.length}‰ª∂)`
            : `„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÁµêÊûú: ${filteredPlaylists.length}‰ª∂ / ÂÖ®${playlists.length}‰ª∂`
          }
        </div>
        
        {playlistsLoading ? (
          <div className={styles.loading}>„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
        ) : filteredPlaylists && filteredPlaylists.length > 0 ? (
          displayMode === 'grid' ? (
            <div className={styles.playlistsGrid}>
              {sortPlaylists(filteredPlaylists, sortOrder).map((playlist) => (
                <Link 
                  href={`/playlists/${playlist.id}`} 
                  key={playlist.id}
                  className={styles.playlistItem}
                >
                  <div className={styles.playlistCover}>
                    {playlist.cover_image_url ? (
                      <img 
                        src={playlist.cover_image_url} 
                        alt={playlist.name}
                        className={styles.playlistImage}
                      />
                    ) : (
                      <div 
                        className={styles.playlistPlaceholder}
                        style={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' }}
                      >
                        <span>üéµ</span>
                      </div>
                    )}
                  </div>
                  <div className={styles.playlistInfo}>
                    <h4 className={styles.playlistName}>{playlist.name}</h4>
                    
                    {/* Âπ¥„Å®„Çø„Ç∞„ÅÆË°®Á§∫ */}
                    <div className={styles.playlistMetadata}>
                      {playlist.year && (
                        <span className={`${styles.metadataItem} ${styles.year}`}>
                          {playlist.year}
                        </span>
                      )}
                      {playlist.tags && (
                        <span className={`${styles.metadataItem} ${styles.tag}`}>
                          {playlist.tags}
                        </span>
                      )}
                    </div>
                    
                    <p className={styles.playlistStats}>
                      {playlist.track_count || 0}Êõ≤ ‚Ä¢ {formatPlaylistDate(playlist.updated_at || playlist.created_at)}
                    </p>
                  </div>
                </Link>
              ))}
            </div>
          ) : (
            <div className={styles.playlistsList}>
              {sortPlaylists(filteredPlaylists, sortOrder).map((playlist) => (
                <Link 
                  href={`/playlists/${playlist.id}`} 
                  key={playlist.id}
                  className={styles.playlistListItem}
                >
                  <div className={styles.playlistCover}>
                    {playlist.cover_image_url ? (
                      <img 
                        src={playlist.cover_image_url} 
                        alt={playlist.name}
                        className={styles.playlistImage}
                      />
                    ) : (
                      <div 
                        className={styles.playlistPlaceholder}
                        style={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' }}
                      >
                        <span>üéµ</span>
                      </div>
                    )}
                  </div>
                  <div className={styles.playlistListInfo}>
                    <div className={styles.playlistListTitle}>
                      {playlist.name}
                    </div>
                    
                    {/* Âπ¥„Å®„Çø„Ç∞„ÅÆË°®Á§∫ */}
                    <div className={styles.playlistListMetadata}>
                      {playlist.year && (
                        <span className={`${styles.metadataItem} ${styles.year}`}>
                          {playlist.year}
                        </span>
                      )}
                      {playlist.tags && (
                        <span className={`${styles.metadataItem} ${styles.tag}`}>
                          {playlist.tags}
                        </span>
                      )}
                    </div>
                  </div>
                  
                  <div className={styles.playlistListRight}>
                    <div className={styles.playlistListTrackCount}>
                      {playlist.track_count || 0}Êõ≤ ‚Ä¢ {formatPlaylistDate(playlist.updated_at || playlist.created_at)}
                    </div>
                  </div>
                </Link>
              ))}
            </div>
          )
        ) : (
          <div className={styles.noPlaylists}>
            {filteredPlaylists.length === 0 && playlists.length > 0 ? (
              <>
                <p>„Éï„Ç£„É´„Çø„ÉºÊù°‰ª∂„Å´‰∏ÄËá¥„Åô„Çã„Éó„É¨„Ç§„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                <p>„Éï„Ç£„É´„Çø„Éº„ÇíÂ§âÊõ¥„Åô„Çã„Åã„ÄÅ„É™„Çª„ÉÉ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
              </>
            ) : (
              <>
                <p>„Éó„É¨„Ç§„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                <p>Êõ≤„ÅÆ‰∏âÁÇπ„É°„Éã„É•„Éº„Åã„Çâ„Éó„É¨„Ç§„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ</p>
                <p>„Åæ„Åü„ÅØ„ÄÅÊó¢Â≠ò„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà„Å´Êõ≤„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô</p>
              </>
            )}
          </div>
        )}
      </div>

      {/* Ë¶ñËÅ¥Â±•Ê≠¥„Çµ„Éû„É™„Éº */}
      {stats && (
        <div className={styles.statsCard}>
          <h3>Ë¶ñËÅ¥Â±•Ê≠¥„Çµ„Éû„É™„Éº</h3>
          <div className={styles.statsGrid}>
            <div className={styles.statItem}>
              <span className={styles.statLabel}>Á∑èË¶ñËÅ¥ÊôÇÈñì</span>
              <span className={styles.statValue}>{formatDuration(stats?.totalPlayTime || 0)}</span>
            </div>
            <div className={styles.statItem}>
              <span className={styles.statLabel}>Ë¶ñËÅ¥„Åó„ÅüÊõ≤Êï∞</span>
              <span className={styles.statValue}>{stats?.uniqueTracks || 0}Êõ≤</span>
            </div>
            <div className={styles.statItem}>
              <span className={styles.statLabel}>„ÅäÊ∞ó„Å´ÂÖ•„Çä</span>
              <span className={styles.statValue}>{stats?.completedTracks || 0}Êõ≤</span>
            </div>
          </div>
        </div>
      )}

      {/* Ë¶ñËÅ¥Â±•Ê≠¥„ÉÜ„Éº„Éñ„É´ */}
      <div className={styles.historyCard}>
        <div className={styles.historyHeader}>
          <h3>Ë¶ñËÅ¥Â±•Ê≠¥</h3>
          <button 
            onClick={refreshPlayHistory}
            className={styles.refreshButton}
            disabled={isLoading}
          >
            {isLoading ? 'Êõ¥Êñ∞‰∏≠...' : 'Ë¶ñËÅ¥Â±•Ê≠¥Êõ¥Êñ∞'}
          </button>
        </div>
        
        {isLoading ? (
          <div className={styles.loading}>Ë¶ñËÅ¥Â±•Ê≠¥„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
        ) : playHistory && playHistory.length > 0 ? (
          <div className={styles.tableContainer}>
            <table className={styles.historyTable}>
              <thead>
                <tr>
                  <th>ÈÄö„ÅóNO</th>
                  <th>Ë¶ñËÅ¥ÈñãÂßã„Çø„Ç§„É†</th>
                  <th>„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà</th>
                  <th>„Çø„Ç§„Éà„É´</th>
                  <th>„Çπ„Çø„Ç§„É´</th>
                  <th>„ÇΩ„Éº„Çπ</th>
                  <th>„ÅäÊ∞ó„Å´ÂÖ•„Çä</th>
                </tr>
              </thead>
              <tbody>
                {currentPageGroupedData.map((item, index) => (
                  item.type === 'date-separator' ? (
                    <tr key={item.id}>
                      <td colSpan="7" className={styles.dateSeparator}>
                        <span>{item.date} ({item.dayOfWeek})</span>
                      </td>
                    </tr>
                  ) : (
                    <tr key={item.data.id}>
                      <td>{(startIndex + item.originalIndex + 1).toString().padStart(3, '0')}</td>
                      <td>{formatDate(item.data.created_at)}</td>
                      <td>{item.data.artist_name || 'Unknown Artist'}</td>
                      <td>{formatTrackTitle(item.data.track_title)}</td>
                      <td>{formatStyle(item.data.style_name)}</td>
                      <td>{formatSource(item.data.source)}</td>
                      <td>
                        {(item.data.is_favorite || likedTracks.has(item.data.track_id)) && (
                          <img
                            src="/svg/heart-solid.svg"
                            alt="Favorite"
                            style={{ 
                              width: "14px", 
                              height: "14px",
                              filter: "invert(27%) sepia(51%) saturate(2878%) hue-rotate(86deg) brightness(104%) contrast(97%)"
                            }}
                          />
                        )}
                      </td>
                    </tr>
                  )
                ))}
              </tbody>
            </table>
            {renderPagination()}
          </div>
        ) : (
          <div className={styles.noHistory}>
            <p>Ë¶ñËÅ¥Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
            <p>Êõ≤„ÇíÂÜçÁîü„Åô„Çã„Å®„ÄÅ„Åì„Åì„Å´Â±•Ê≠¥„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
          </div>
        )}
      </div>

      {accountSettings}
    </div>
  );
}
